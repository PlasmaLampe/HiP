\chapter[Draft of the application]{Draft of the application}
To handle all these problems that have been described above within the section about the current situation, we will create a smartphone application that gets supported by a backend web-server. The master thesis will handle the planning respectively cost estimation of the different parts/features of the system and will, after the needed technologies/frameworks are elaborated and evaluated, include a prototypical implementation of the needed components.
But at first, we will start with the first step in a development process; the requirements engineering.

\section{Requirements engineering}
Because the HiP-Application will be developed closely together with our \textit{costumer}, other working-groups at the university of paderborn, the whole process starts with the requirements engineering phase.

First of all, a requirement is defined as "[...]A condition or capability that must be met or possessed by a system or system component to satisfy a contract, standard, specification, or other formally imposed documents[...]" (\cite{IEEEReq}).

We started the development with a requirements engineering meeting together with our \textit{customer} and ended up with a couple of cards with written user stories. Afterwards, these stories got refined to concrete requirements, which are measurable and prioritized. A complete list of all requirements, which were derived from these user stories, can be found within the appendix in Table \ref{RequirementsFrontend} and \ref{RequirementsBackend}. These requirements can directly be used to derive test cases from them, which is good because we will use a \ac{TDD} driven development approach in every sprint. 

Because the system will be quite complex and big, we will need a couple of frameworks and libraries, which have mostly been explained in section \ref{background}. 
The usage of these external components and their structure will be the main topic of the next section.

\section{Use Cases - User stories}
The system in its whole will have four different kinds of users, which correspond to four different roles within the system. The roles are briefly described in the following:

\begin{enumerate}
	\item Supervisors: Supervisors work at the university and create groups, topics and are able to review the information of their groups. The main goal of supervisor is the betreuung \todo{dict} of groups.
	\item Students: Students are placed in groups by their supervisor and work on a specific topic. They are able to hand in their work for review by the supervisor. 
	\item Admin: The admins are able to assign users to specific roles and edit the system itself (e.g., edit translations, etc. )
	\item Master: People, who have the role \textit{Master}, are able to accept respectively reject topics for the front-end application
\end{enumerate}

\todo{include use case diagram}

After we have now seen the different roles that are involved in this system, we will include two use case tables as an example for the usage of the system here. However, a complete list of use case scenarios would be to large for this thesis.

 \begin{table}[h]
\scriptsize
 \caption{Use Case Scenario: student changes content on a topic}
 \begin{tabular}{lll}
	\toprule
  Step: & Involved: & Description of the activity: \\ 
\cmidrule(rl){1-1}\cmidrule(rl){2-2}\cmidrule(rl){3-3}
  	0 	& Student & logs into the system \\
	1	& Student	& navigates to the correct group \\
	2	& Student & navigates to the topic he wants to work on \\
	3	& Student & changes content on the topic \\
	4	& Student & saves the changes \\	
	5	& Student & logs out \\
	\bottomrule
 \end{tabular}
 \label{tab:ucTopicChange}
 \end{table} 

Table \ref{tab:ucTopicChange} shows that when a student wants to change the content of a topic he is working on, he needs to log into the system, navigate to the group and topic and is then able to change the content.
 
 \begin{table}[h]
\scriptsize
 \caption{Use Case Scenario: Supervisor creates a new group}
 \begin{tabular}{lll}
	\toprule
  Step: & Involved: & Description of the activity: \\ 
\cmidrule(rl){1-1}\cmidrule(rl){2-2}\cmidrule(rl){3-3}
  	0 	& Supervisor & logs into the system \\
	1	& Supervisor & navigates to create group view \\
	2	& Supervisor & inputs name, member, topics, etc. \\
	3	& Supervisor & saves the group \\	
	4	& Supervisor & logs out \\
	\bottomrule
 \end{tabular}
 \label{tab:ucGroupCreation}
 \end{table} 

The second use case scenario in Table \ref{tab:ucGroupCreation} shows that it will be quite easy for a supervisor to create a new group. He only needs to log into the system, open the correct view and input all needed information, like members of the group. 

\todo{include complete "group and topic" lifecycle as an activity diagram}

\todo{include simple sequence diagrams}

Now, after we have seen what the application is about and which tools and frameworks are in general used to create the application, we will now take a closer look at the usage of the different components (e.g., frameworks, libraries and tools) and how the will work together.

\section{Usage of the components}


\subsection{Framework and library stack}


\section{Architecture of the application}
The architecture design in agile projects is slightly different from the design in common respectively classical development projects. Within a classical development process, one would design the architecture of the system in its whole, before the actual programming phase is started\todo{ref}. This is, obviously, not applicable within an agile development approach. As \cite{Mast2013} points out, agile architecture design has the the following important attributes:

\begin{enumerate}
	\item At the beginning, one has only an idea about the architecture, which describes the most important constraints. However, there has to be enough space to be able to adapt the architecture to new or changing requirements within the development process.	%\item Damit wird ein iteratives Vorgehen ermöglicht und architektonische Ent- scheidungen können bis zum „ hinausgezogen werden, d. h. sie werden zum spätmög- lichsten Zeitpunkt getroffen und da- nach meist sofort umgesetzt.
	\item This enables the developer to be able to use an iterative development style and to postpone important development choices to the \textit{Least Responsible Moment}. The \textit{Least Responsible Moment} is the latest possible point in time, where you can implement an architecture decision 	%\item Detaillierte Strukturen und technische Konzepte entstehen unterwegs.
	\item This way, detailed structures and technical concepts are created on-the-fly, while the application gets developed
\end{enumerate}

\begin{figure}[th]
\centerline{\includegraphics[width=1\textwidth]{gfx/architecture}}
\caption{The general 3-tier architecture of the HiP-application with both presentation tier}
\label{hip:architecture}
\end{figure}

Similarly, we will choose a 3-tier architecture for the development for the application, which is, according to \cite{Eckerson1995}, a quite common for Client/Server respectively web applications. Within our application, the 3-tier architecture is nice because it enables us to exchange the presentation tier easily, which is a feature that we will need to support the web-backend and a smartphone front-end. The main idea about the architecture is shown in Figure \ref{hip:architecture}. The figure shows the storage tier, which will be driven by a MongoDB. The data that will be stored in the MongoDB gets prepared by the Play-Framework, which will create the foundation for the application tier. Nevertheless, we want to build a fast and application that is able to give instant feedback to the user within the \ac{UI}. Because of that, parts of the application tier need to be included on the client side within the presentation tier. So, we will create a thick-client. \todo{ref}
\todo{Tier vs Layer} 

However, more detailed decisions about the architecture design are postponed to the \textit{least responsible moment}, as it has been suggested by \cite{Mast2013}.

After we have now seen the general architecture, we will take a look at the different part of the system in more detail.
 
\section{Backend (Web-Server)}
Another important part of the system is contained within the backend-web-server. The backend should contain the whole data handling and assessment. The students should be able to add data to the system (e.g., a textual article, graphics, \ac{AR}-data, etc.) and to modify existing data via a \ac{CMS}. These entries get reviewed, for example by the course supervisor, and unlocked for the frontend application. To do this, the backend needs features like annotations and highlighting, which should be private for a specific user. By using this, the supervisor can evaluate the given texts right within the \ac{CMS} and give his final judgement. If the supervisor is not satisfied with the quality of the given text, he should be able to send the document back to the student, to get a revised and updated version of the document. If the supervisor is satisfied, he can unlock the information for showing in the frontend application.

The data should be stored in a way that it can be shown within an \ac{AR}-environment in the smartphone application. Of course, we will need some mechanism to structure the data, for example tags or stored categories. This kind of information (especially tags) are also very important for the described filtering techniques on the client side.

\begin{figure}[th]
\centerline{\includegraphics[width=1\textwidth]{gfx/mockup_web_1}}
\caption{A mockup showing the augmentation editor that will be included in the web-application. The editor will be used to edit the point-clouds, which have been added with the help of the smartphone-application}
\label{web1}
\end{figure}

Furthermore, the backend should include a way to modify the point-clouds of the objects that has been scanned with the smartphone application. It will need features to add annotations directly to these point-clouds to show them afterwards within the \ac{AR}-environment. This editor will be created on the basis of \ac{HTML5} and \ac{WebGL}. A mockup of this site is shown in Figure \ref{web1}. These annotations should also be assessable and (un-)lockable for the supervisor. 

\subsection{Cost estimation of the backend}

\subsection{Input data/content via CMS in the system}

\subsection{Manage content as a reviewer}

\subsubsection{AnnotateIt inclusion}

\subsubsection{JWT}

\subsection{Including a 3D-Tooling system for point-clouds (WebGL)}

\section{Frontend (App)}
\begin{figure}[th]
\centerline{\includegraphics[width=0.5\textwidth]{gfx/mockup_app_1}}
\caption{A mockup showing the main page of the frontend application showing a map of paderborn and a general overview about the UI-elements}
\label{app1}
\end{figure}

The smartphone application is the part of the system that gets shipped to the end-user (respectively downloaded via an App-Store like Google-Play). The user can use the app to find interesting places respectively objects in Paderborn and is able to start a navigation to the place/object easily. Furthermore, the user can get an overview about all places in Paderborn by activating a map that shows all entries within the system. A mockup of this view is shown in Figure \ref{app1}. Of course, the user will be able to set up specific filters like 'show only art', 'show only historic buildings' or 'use simplified language' to adapt the system to his own experiences and educational qualifications. Moreover, if the university courses would add information over years, the system will need filtering features like this to handle the complexity of the data.

After an user has reached an interesting place, he can use the details tab to switch into the \ac{AR}-mode. With this view, the user can use the smartphone-camera to embed information, which has been added via the backend, right into the picture of the object. An mockup of this view is shown in Figure \ref{app2}. 
To create a feasible input for the \ac{AR} system, the user should be able to scan objects in 3D right with his smartphone application and send the data (i.e., a point-cloud of the scanned object), back to the web-server.  Afterwards, the user can add annotations to the point-cloud via the web-backend of the system.  

\begin{figure}[th]
\centerline{\includegraphics[width=0.7\textwidth]{gfx/mockup_app_2}}
\caption{A mockup showing the details page of the "Dreihasenfenster" while the camera of the smartphone is pointing to the window itself}
\label{app2}
\end{figure}

\subsection{Cost estimation of the frontend}				
  
\subsection{Input data into the system (scan objects and annotate them)} 

\subsection{Show close "interesting places" within a map /  via a overlay} 

\subsection{Navigation to "interesting places"}
				
\section{Interface}							 

\subsection{Data format for \ac{AR} files}